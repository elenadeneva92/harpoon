package agentrepr

import (
	"fmt"
	"os"
	"sort"
	"strings"
	"testing"
)

func TestStateTransitions(t *testing.T) {
	m := map[string]string{}

	for _, r := range []route{
		// from initialState
		route{[]transition{schedule}, pendingScheduleState},
		route{[]transition{unschedule}, nil}, // this is important; it can happen!
		route{[]transition{created}, createdState},
		route{[]transition{running}, runningState},
		route{[]transition{stopped}, createdState},
		route{[]transition{deleted}, nil},
		route{[]transition{timeout}, nil},

		// from pendingSchedule
		route{[]transition{schedule, schedule}, pendingScheduleState},
		route{[]transition{schedule, unschedule}, pendingScheduleState},
		route{[]transition{schedule, created}, createdState},
		route{[]transition{schedule, running}, runningState},
		route{[]transition{schedule, stopped}, createdState},
		route{[]transition{schedule, deleted}, nil},
		route{[]transition{schedule, timeout}, nil},

		// from createdState
		route{[]transition{created, schedule}, createdState},
		route{[]transition{created, unschedule}, createdPendingUnscheduleState},
		route{[]transition{created, created}, createdState},
		route{[]transition{created, running}, runningState},
		route{[]transition{created, stopped}, createdState},
		route{[]transition{created, deleted}, nil},
		route{[]transition{created, timeout}, createdState},

		// from runningState
		route{[]transition{running, schedule}, runningState}, // this is important; it can happen!
		route{[]transition{running, unschedule}, runningPendingUnscheduleState},
		route{[]transition{running, created}, createdState},
		route{[]transition{running, running}, runningState},
		route{[]transition{running, stopped}, createdState},
		route{[]transition{running, deleted}, nil},
		route{[]transition{running, timeout}, runningState},

		// from createdPendingUnscheduleState
		route{[]transition{created, unschedule, schedule}, createdPendingUnscheduleState},
		route{[]transition{created, unschedule, unschedule}, createdPendingUnscheduleState},
		route{[]transition{created, unschedule, created}, createdPendingUnscheduleState}, // command might not have arrived yet
		route{[]transition{created, unschedule, running}, runningPendingUnscheduleState}, // command might not have arrived yet
		route{[]transition{created, unschedule, stopped}, createdPendingUnscheduleState}, // command might not have arrived yet
		route{[]transition{created, unschedule, deleted}, nil},
		route{[]transition{created, unschedule, timeout}, createdState},

		// from runningPendingUnscheduleState
		route{[]transition{running, unschedule, schedule}, runningPendingUnscheduleState},
		route{[]transition{running, unschedule, unschedule}, runningPendingUnscheduleState},
		route{[]transition{running, unschedule, created}, createdPendingUnscheduleState}, // command might not have arrived yet
		route{[]transition{running, unschedule, running}, runningPendingUnscheduleState}, // command might not have arrived yet
		route{[]transition{running, unschedule, stopped}, createdPendingUnscheduleState}, // command might not have arrived yet
		route{[]transition{running, unschedule, deleted}, nil},
		route{[]transition{running, unschedule, timeout}, runningState},
	} {
		testRoute(t, r, m)
	}

	if !t.Failed() {
		writeDotFile(m)
	}
}

func testRoute(t *testing.T, r route, m map[string]string) {
	var fn stateFn = initialState

	for _, tr := range r.transitions {
		if fn.String() == stateFn(nil).String() {
			t.Errorf("%s %v: illegal advancement past <nil> state", fn, r.transitions)
			return
		}

		key := fmt.Sprintf("%s %s", (fn).String(), tr.String())

		fn = fn(tr)

		existing, ok := m[key]
		if ok && existing != fn.String() {
			t.Errorf("%s already recorded as %s, but we get %s", key, existing, fn.String())
			return
		}

		m[key] = fn.String()
	}

	if want, have := r.final.String(), fn.String(); want != have {
		t.Errorf("%s %v: want %s, have %s", fn, r.transitions, want, have)
		return
	}

	//t.Logf("%s %v: %s OK", nameOf(initialState), r.transitions, nameOf(fn))
}

type route struct {
	transitions []transition
	final       stateFn
}

func writeDotFile(m map[string]string) {
	f, err := os.Create("state_diagram.dot")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintf(f, "// This file is automatically generated from a unit test.\n")
	fmt.Fprintf(f, "// Check it in and make sure it doesn't change between revisions!\n")
	fmt.Fprintf(f, "digraph G {\n")
	fmt.Fprintf(f, "	node [shape=\"box\"];\n")
	fmt.Fprintf(f, "	rankdir=LR;\n")
	fmt.Fprintf(f, "\n")

	var a sort.StringSlice
	for key := range m {
		a = append(a, key)
	}
	a.Sort()

	for _, key := range a {
		toks := strings.SplitN(key, " ", 2)
		src, label, dst := toks[0], toks[1], m[key]
		if src == dst {
			continue
		}
		fmt.Fprintf(f, "	%s -> %s [label=\"%s\"];\n", src, dst, label)
	}

	fmt.Fprintf(f, "}\n")
}
